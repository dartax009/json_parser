# JSON PARSER

Библиотека для проверки json сигнатуры и ее обработки.

Для сборки и работы под ОС LINUX требует поддержку следующих библиотек:
- stdlib.h
- string.h
- stdint.h
- sys/mman.h
- sys/stat.h
- fcntl.h
- unistd.h
- stdio.h, если необходим вывод информации на экран о возникшей ошибки во время работы (по умолчанию не используется)

Для остальных сборок:
- stdlib.h
- string.h
- stdint.h
- stdio.h, если необходим вывод информации на экран о возникшей ошибки во время работы (по умолчанию не используется)

Для включения вывода информации о возникших ошибках на экран необходимо опрделить define "PRINT_ERROR_INFO"

Данная библиотека использует динамическую память при своей работе (malloc)

## Что может?

- Проверять json строку на соответствии структуре
- Предоставляет возможность обрабатывать поля json строки (вызов пользовательских функций в процессе обработки)

## Что не может?

- Проверять все возможные комбинации json строки (правдивость утверждения под вопросом - необходимо больше тестов)
- Стабильно работать (правдивость утверждения под вопросом - необходимо больше тестов)

## Интерфейс взаимодействия с библиотекой
### Библиотека предоставляет следующие функции:

|№|Название|Прототип|Аргументы|Возвращаемые значения|
|-|-|-|-|-|
|1|Разобрать json в соответствии с json_map_t|uint8_t parsing_json (file_inf_t *file_inf, const json_map_t *json_map)|file_inf_t *file_inf - информация о строке, ее размере и файле, если он был открыт с помощью init_json_mmap <br> const json_map_t *json_map - структура ожидаемого json| [0] - Успешное завершение работы функции <br> [>0] - Ошибка. Данная библиотека возвращает 1 на любую ошибку, которую обнаружила, любое другое значение может быть использовано в пользовательских функциях|
|2|Открыть файл json и спроецировать его в ОЗУ для дальнейшей работы|uint8_t init_json_mmap (char *path, file_inf_t *file_inf)|char *path - путь до файла <br> file_inf_t *file_inf - информация об открытом файле|[0] - Успешное завершение работы функции<br>[1] - Ошибка. Не удалось открыть файл<br>[2] - Ошибка. Не удалось получить информацию о размере файла<br>[3] - Ошибка. Не удалось спроецировать файл в ОЗУ|
|3|Закрыть файл json и удалить его проекцию в ОЗУ|uint8_t deinit_json_mmap (file_inf_t *file_inf)|file_inf_t *file_inf - информация о ранее открытом файле|[0] - Успешное завершение работы функции<br>[1] - Ошибка. Не удалось удалить проекцию файла из ОЗУ<br>[2] - Ошибка. Не удалось закрыть файл|

### Прототип функции обработчика поля:
```c
typedef uint8_t (*handler_json)(const char *fild_value, size_t size);
```
- fild  [in] указатель на начало поля, данные которого необходимо сохранить
- size  [in] размер строки данных
- [0] - Успешное завершение работы
- [>0] - Пользовательский код ошибки
 
Функции обработчика предназначены для выполнения каких-то действий в процессе обработки строки json. В разделе "Работа библиотеки" будут примеры, но если вкратце, то:

У нас есть ожидаемое поле "name" и мы хотим сохранить его значение в свою структуру, для этого создается структура обработчик этого поля, где происходят необходимые манипуляции с данными, возможно, дополнительные проверки. Есть нюансы, об этом ниже.

### Структура file_inf_t

|№|Название|Назначение|
|-|-|-|
|1|fd|Дискриптор файла|
|2|file_len|Длинна строки json|
|3|file|Указатель на начало json строки, которую необходимо обработать|

- fd - Хранит дискриптор файла, если используется init_json_mmap. Может иметь любое значение если строка уже хранится в ОЗУ
- file_len - Длинна строки json. При использовании init_json_mmap будет получен размер файла откуда берется строка
- file - Начало json строки. При использовании init_json_mmap будет хранить начало shmem (разделяемой памяти) созданной с помощью mmap

### Структура json_map_t
|№|Название|Назначение|
|-|-|-|
|1|field_name|Ожидаемое название поля|
|2|func|Функция обработчик handler_json|
|3|field_type|Тип поля в соответствии с [jsmn.h](https://github.com/zserge/jsmn "Ссылка на git hub разработчика")|
|4|json_map|Указатель на структуру json_map_t|

Самая сложная часть работы с данной библиотекой - это составить ожидаемую "карту" json. Ниже будут приведены примеры.

Дополнительно продублирую информацию про field_type:
```c
typedef enum {
	JSMN_UNDEFINED = 0,
	JSMN_OBJECT = 1 << 0,
	JSMN_ARRAY = 1 << 1,
	JSMN_STRING = 1 << 2,
	JSMN_PRIMITIVE = 1 << 3
} jsmntype_t;
```
- JSMN_UNDEFINED - не известное поле. В данной библиотеки задействуется как один из "стопоров" обработки строки
- JSMN_OBJECT - объект. Все что окружено в "{}"
- JSMN_ARRAY - массив. Все что окружено в "[]"
- JSMN_STRING - строка. Все что окружено в ""
- JSMN_PRIMITIVE - простой тип. true, false, null или любые числа не окруженные ""

При заполнении структуры последним ее элементов всегда должен быть макрос END_MAP_JSON.

## Работа библиотеки

Данная библиотека основана на [jsmn.h](https://github.com/zserge/jsmn "Ссылка на git hub разработчика") и полностью опирается на ее принцип работы с json.

Рассмотрим пример из [jsmn.h](https://github.com/zserge/jsmn "Ссылка на git hub разработчика"):
```json
{
    "name" : "Jack",
    "age" : 27
}
```
Выше описана простая json строка, ее карат будет выглядеть следующим образом:
```c
static const json_map_t any_name[] =
{
    {"name", any_handler1, JSMN_STRING, NULL},
    {"age", any_handler2, JSMN_PRIMITIVE, NULL},

    END_MAP_JSON
};
```
При построении карты стоит учитывать, что первый "{}" (JSMN_OBJECT) не учитывается, так как он сам собой разумеется. И тогда получается, что мы ожидаем или поле "name" или "age" (порядок не важен. В настоящий момент библиотека не умеет его контролировать). У нее будет какой-то обработчик (данное поле может быть NULL, если с полем ничего не требуется). Значение поля "name" будет JSMN_STRING, а поля "age" JSMN_PRIMITIVE. Последнее поле NULL, о нем позже.

Усложняем пример:
```json
{
    "name":
        {
            "first": "Jack",
            "last": "Hugecock"
        },
    "age" : 27
}
```
Теперь поле значение поля "name" это объект и карта усложняется до:
```c
static const json_map_t name_map[] =
{
    {"first", any_handler, JSMN_STRING, NULL},
    {"last", any_handler, JSMN_STRING, NULL},

    END_MAP_JSON
};

static const json_map_t person_map[] =
{
    {"name", NULL, JSMN_OBJECT, name_map},
    {"age", any_handler2, JSMN_PRIMITIVE, NULL},

    END_MAP_JSON
};
```
В данном примере принцип, следующий: мы ожидаем, что поле "name" будет объектом, который тоже имеет свою структуру, поэтому мы создаем "name_map" и в нем описываем какие поля мы ждем, а указатель на новую структуру помещаем в четвертое поле структуры "json_map_t". При работе с данным json библиотека, в случае нахождения поля "name", "увидит", что она JSMN_OBJECT, и "переключит" структуру для проверки, пока поля этого объекта "не закончатся".

Добавим массив:
```json
{
    "name":
        {
            "first": "Jack",
            "last": "Hugecock"
        },
    "age" : 27,
    "hobbies": [
        "Reading",
        "Walking a cock"
    ]
}
```
Карта для такого безобразия будет выглядеть следующим образом:
```c
static const json_map_t hobbies_map[] =
{
    {NULL, any_handler, JSMN_STRING, NULL},

    END_MAP_JSON
};
static const json_map_t name_map[] =
{
    {"first", any_handler, JSMN_STRING, NULL},
    {"last", any_handler, JSMN_STRING, NULL},

    END_MAP_JSON
};

static const json_map_t person_map[] =
{
    {"name", NULL, JSMN_OBJECT, name_map},
    {"age", any_handler, JSMN_PRIMITIVE, NULL},
    {"hobbies", NULL, JSMN_ARRAY, hobbies_map},

    END_MAP_JSON
};
```
Тут мы ожидаем, что поле "hobbies" будет массивом, со своей структурой, поэтому необходимо действовать так же, как с объектом - создать новую карту и связать ее с четвертым полем.

В данном примере элементы массива "hobbies" не имеют имени, поэтому необходимо указать NULL в первом поле структуры. В таком случае библиотека будет ориентироваться только по типу (третье поле структуры). Ожидается что на все элементы массива будет одинаковая реакция. Если нет, то дальнейшую обработку необходимо производить на стороне пользователя в функции "any_handler".

Еще изменим json:

```json
{
    "name":
        {
            "first": "Jack",
            "last": "Hugecock"
        },
    "age" : 27,
    "phoneNumbers": [
        {
            "type": "mobile",
            "number": "+7-123-456-7890"
        },
        {
            "type": "home",
            "number": "+7-987-654-3210"
        }
    ],
}
```
Убрали хобби ~~(У кого на него вообще есть время)~~ и добавили массив структур. Следовательно карта будет следующая:
```c
static const json_map_t phoneNumbers_obj[] =
{
    {"type", any_handler, JSMN_STRING, NULL},
    {"number", any_handler, JSMN_STRING, NULL},

    END_MAP_JSON
};

static const json_map_t phoneNumbers_map[] =
{
    {NULL, NULL, JSMN_OBJECT, phoneNumbers_obj},

    END_MAP_JSON
};
static const json_map_t name_map[] =
{
    {"first", any_handler, JSMN_STRING, NULL},
    {"last", any_handler, JSMN_STRING, NULL},

    END_MAP_JSON
};

static const json_map_t person_map[] =
{
    {"name", NULL, JSMN_OBJECT, name_map},
    {"age", any_handler, JSMN_PRIMITIVE, NULL},
    {"phoneNumbers", NULL, JSMN_ARRAY, phoneNumbers_map},

    END_MAP_JSON
};
```
Тут "phoneNumbers", так же, как и "hobbies", является JSMN_ARRAY - организовали переход на "уровень ниже". Ожидаем, что "phoneNumbers" будет состоять из объектов без имени, по этому первое и второе поле NULL, а третье JSMN_OBJECT. Четвертым полем мы организуем переход на структуру этого объекта. А дальше, как в первом примере.

Так же может быть ситуация, когда необходимо знать сколько элементов входит в array или object (для динамических данных):

```json
{
    "any_array": [
        "any1",
        "any2",
        "any3"
    ],
    "any_object":{
        "any1":1,
        "any2":2,
        "any3":3
    }
}
```

Для указанного выше примера будет следующая карты:

```c
static const json_map_t any_array_map[] =
{
    {NULL, NULL, JSMN_STRING, NULL},

    END_MAP_JSON
};

static const json_map_t any_object_map[] =
{
    {"any1", NULL, JSMN_PRIMITIVE, NULL},
    {"any2", NULL, JSMN_PRIMITIVE, NULL},
    {"any3", NULL, JSMN_PRIMITIVE, NULL},

    END_MAP_JSON
};

static const json_map_t any_map[] =
{
    {"any_array", any_handler_array, JSMN_ARRAY, any_array_map},
    {"any_object", any_object_handler, JSMN_OBJECT, any_object_map},

    END_MAP_JSON
};
```

В таком случае стоит учитывать, что аргумент size обработчика any_handler_array/any_object_handler будет принимать значение кол-ва элементов входящих в них (в данном случае 3).

Вроде как (исходя из немногочисленных тестов), все эти переходы и вложенности могут быть какими угодно сложными, главное не запутаться в составление ~~натальной~~ карты.

Как это выглядит в коде - можно глянуть в example/ там лежит тестовый json и карта.

Чтоб организовать проверку на соответствие карте, но без какой-либо доп. обработки в процессе, необходимо заполнить все обработчики NULL

## Как использовать
- Составить ожидаемую карту
- Написать необходимые обработчики
- Если надо обрабатывать json из файла, то последовательность вызовов, следующая:
```c
file_inf_t fl_inf = {0};    // Создаем структуру для хранения json
init_json_mmap("any/path/to/json", &fl_inf); // Открываем файл и вытягиваем его в ОЗУ

parsing_json(&fl_inf, my_map);   // Анализируем и обрабатываем json

deinit_json_mmap(&fl_inf); // Освобождаем ресурсы
```
- Если уже есть указатель на json, то последовательность вызовов, следующая:
```c
file_inf_t fl_inf = {0};    // Создаем структуру для хранения json

fl_inf.file = ptr_to_json;      // Ставим указатель
fl_inf.file_len = size_json;    // Указываем размер строки

parsing_json(&fl_inf, my_map);   // Анализируем и обрабатываем json
```

## Для включения в проект
Для включения в проект необходимо скомпилировать файл json_parser/json_form_chech.c и json_parser/jsmn/jsmn.c

## Дополнительная информация
Если это кто-то видит, то буду рад помощи с доведением этого микро-проекта до ума